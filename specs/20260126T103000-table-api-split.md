# Table API Split: Versioned vs Dynamic

## Overview

This spec defines two distinct table APIs that serve different use cases. The current `table-helper.ts` will be split into two separate implementations:

1. **Versioned Tables** - Row-level atomic writes with schema versioning
2. **Dynamic Tables** - Cell-level CRDT merging for flexible/collaborative data

### Related Specs

- `specs/20260125T120000-versioned-table-kv-specification.md` - Versioned schema internals (YKeyValue, migrate-on-read)
- `specs/20260126T120000-static-workspace-api.md` - Full API for defineTable, defineKv, defineWorkspace, and composability

---

## Why Two APIs?

The fundamental tension is between **schema evolution** and **cell-level collaboration**:

| Requirement | Versioned Tables | Dynamic Tables |
|-------------|------------------|----------------|
| Schema versioning | Yes (row is atomic unit) | No (cells can drift) |
| Concurrent cell edits merge | No (last-write-wins on row) | Yes (CRDT merge) |
| Partial updates | No (always full row) | Yes (individual cells) |
| Memory growth | Bounded (YKeyValue) | Unbounded (Y.Map history) |
| Type safety | Fully typed | Runtime/dynamic |

**You can't have both** because schema versioning requires the entire row to be written atomically. If cells can be edited independently, different cells could be at different schema versions after concurrent edits.

---

## Naming Options

Both APIs deal with "tables" but have fundamentally different characteristics. Here are naming options:

### Option A: By Write Granularity
- `createRowTables()` - row-level writes
- `createCellTables()` - cell-level writes

### Option B: By Primary Characteristic
- `createVersionedTables()` - emphasizes schema versioning capability
- `createCollaborativeTables()` - emphasizes CRDT merging

### Option C: By Metaphor
- `createTables()` - traditional database tables (row-level, typed)
- `createGrids()` or `createSheets()` - spreadsheet-like (cell-level, dynamic)

### Option D: By Use Case
- `createTables()` - structured data with schemas
- `createDynamicTables()` - flexible/user-defined data

### Recommendation

**Option D** feels most intuitive:
- `createTables()` is the "default" for most use cases (structured data)
- `createDynamicTables()` signals "this is for special cases where you need flexibility"

Alternative: Keep both under `createTables()` with a mode option:
```typescript
createTables(ydoc, definitions, { mode: 'versioned' })  // default
createTables(ydoc, definitions, { mode: 'collaborative' })
```

But this hides the fundamental difference. Separate functions make the choice explicit.

---

## API 1: Versioned Tables (Row-Level)

**Implementation**: See `specs/20260125T120000-versioned-table-kv-specification.md`

**Storage**: YKeyValue (bounded memory)
```
Y.Doc
└── tables (Y.Map<tableName, YKeyValue>)
     └── posts (YKeyValue<{ key: string, val: Row }>)
          ├── { key: "row-1", val: { id, title, views, _v: "3" } }
          └── { key: "row-2", val: { id, title, views, _v: "3" } }
```

### Definition API

```typescript
import { defineTable, createTables } from 'epicenter';
import { type } from 'arktype';

const posts = defineTable('posts')
  .version(type({ id: 'string', title: 'string', _v: '"1"' }))
  .version(type({ id: 'string', title: 'string', views: 'number', _v: '"2"' }))
  .migrate((row) => {
    if (row._v === '1') return { ...row, views: 0, _v: '2' as const };
    return row;
  });

const tables = createTables(ydoc, { posts });
```

### Usage API

```typescript
// Write (always full row, always latest schema)
tables.posts.set({ id: '1', title: 'Hello', views: 0, _v: '2' });
tables.posts.setMany([...rows]);

// Read (validates + migrates to latest)
const result = tables.posts.get('1');
if (result.status === 'valid') {
  console.log(result.row.views);  // typed as number
}

// Query
tables.posts.getAll();           // RowResult<TRow>[]
tables.posts.getAllValid();      // TRow[]
tables.posts.filter(r => r.views > 10);
tables.posts.find(r => r.id === '1');

// Delete
tables.posts.delete('1');
tables.posts.deleteMany(['1', '2']);
tables.posts.clear();

// Observe
tables.posts.observe((changedIds) => {
  for (const id of changedIds) {
    const result = tables.posts.get(id);
    // handle change
  }
});

// Metadata
tables.posts.count();
tables.posts.has('1');
```

### Type Signature

```typescript
type VersionedTable<TRow> = {
  // Write
  set(row: TRow): void;
  setMany(rows: TRow[]): void;

  // Read
  get(id: string): GetResult<TRow>;
  getAll(): RowResult<TRow>[];
  getAllValid(): TRow[];
  getAllInvalid(): InvalidRowResult[];

  // Query
  filter(predicate: (row: TRow) => boolean): TRow[];
  find(predicate: (row: TRow) => boolean): TRow | null;

  // Delete
  delete(id: string): DeleteResult;
  deleteMany(ids: string[]): DeleteManyResult;
  clear(): void;

  // Observe
  observe(callback: (changedIds: Set<string>, tx: Y.Transaction) => void): () => void;

  // Metadata
  count(): number;
  has(id: string): boolean;
};
```

### Key Design Decisions

1. **No `insert` vs `update` vs `upsert`** - Just `set`. The row either exists or it doesn't; you're setting its value either way.

2. **No partial updates** - You always write the complete row. This is what enables schema versioning.

3. **Terminology: `set` not `upsert`** - Cleaner mental model. "Set this row's value."

4. **Validation on read, not write** - Writes always use latest schema. Reads validate against union of all versions and migrate.

---

## API 2: Dynamic Tables (Cell-Level)

**Storage**: Y.Map of Y.Maps (cell-level CRDT)
```
Y.Doc
└── tables (Y.Map<tableName, Y.Map<rowId, Y.Map<columnName, value>>>)
     └── posts (Y.Map)
          └── "row-1" (Y.Map)
               ├── "id" → "row-1"
               ├── "title" → "Hello"
               └── "views" → 42
```

### Definition API (Optional Schema)

```typescript
import { createDynamicTables } from 'epicenter';

// Option 1: No schema (fully dynamic)
const tables = createDynamicTables(ydoc);

// Option 2: Optional schema for validation (no versioning)
const tables = createDynamicTables(ydoc, {
  posts: { id: 'string', title: 'string', views: 'number' }
});
```

### Usage API - Top-Level Methods

```typescript
// Cell-level operations
tables.setCell('posts', 'row-1', 'title', 'Hello');
tables.getCell('posts', 'row-1', 'title');  // unknown

// Row-level operations (convenience)
tables.setRow('posts', 'row-1', { id: 'row-1', title: 'Hello', views: 0 });
tables.getRow('posts', 'row-1');  // Record<string, unknown> | null

// Partial row update
tables.updateRow('posts', 'row-1', { title: 'Updated' });

// Delete
tables.deleteRow('posts', 'row-1');
tables.deleteCell('posts', 'row-1', 'views');

// Query
tables.getAllRows('posts');
tables.filterRows('posts', row => row.views > 10);
```

### Usage API - Table Accessor

```typescript
// Get a table reference (untyped)
const posts = tables.table('posts');

// Cell-level
posts.setCell('row-1', 'title', 'Hello');
posts.getCell('row-1', 'title');

// Row-level
posts.setRow('row-1', { id: 'row-1', title: 'Hello' });
posts.getRow('row-1');
posts.updateRow('row-1', { title: 'Updated' });

// Delete
posts.deleteRow('row-1');
posts.deleteCell('row-1', 'views');

// Query
posts.getAll();
posts.filter(row => row.views > 10);

// Observe
posts.observe((changedIds) => { ... });
posts.observeCell('row-1', 'title', (value) => { ... });
```

### Type Signature

```typescript
type DynamicTables = {
  // Cell-level
  setCell(table: string, rowId: string, column: string, value: unknown): void;
  getCell(table: string, rowId: string, column: string): unknown;
  deleteCell(table: string, rowId: string, column: string): void;

  // Row-level
  setRow(table: string, rowId: string, data: Record<string, unknown>): void;
  getRow(table: string, rowId: string): Record<string, unknown> | null;
  updateRow(table: string, rowId: string, partial: Record<string, unknown>): void;
  deleteRow(table: string, rowId: string): void;

  // Query
  getAllRows(table: string): Record<string, unknown>[];
  filterRows(table: string, predicate: (row: Record<string, unknown>) => boolean): Record<string, unknown>[];

  // Table accessor
  table(name: string): DynamicTable;

  // Metadata
  tableNames(): string[];
  hasTable(name: string): boolean;
};

type DynamicTable = {
  setCell(rowId: string, column: string, value: unknown): void;
  getCell(rowId: string, column: string): unknown;
  deleteCell(rowId: string, column: string): void;

  setRow(rowId: string, data: Record<string, unknown>): void;
  getRow(rowId: string): Record<string, unknown> | null;
  updateRow(rowId: string, partial: Record<string, unknown>): void;
  deleteRow(rowId: string): void;

  getAll(): Record<string, unknown>[];
  filter(predicate: (row: Record<string, unknown>) => boolean): Record<string, unknown>[];

  observe(callback: (changedIds: Set<string>) => void): () => void;
  observeCell(rowId: string, column: string, callback: (value: unknown) => void): () => void;

  count(): number;
  has(rowId: string): boolean;
  columns(rowId: string): string[];
};
```

### Key Design Decisions

1. **No typed table access** - `tables.posts` doesn't exist. Always `tables.table('posts')` or `tables.setCell('posts', ...)`.

2. **Cell as first-class citizen** - `setCell`/`getCell` are primary operations, not just row operations.

3. **Partial updates supported** - `updateRow` merges into existing row (cell-level writes under the hood).

4. **No schema versioning** - Schemas (if provided) are for runtime validation only, not migration.

5. **Cell-level observation** - Can observe individual cells, not just rows.

---

## Comparison Summary

| Aspect | `createTables()` | `createDynamicTables()` |
|--------|------------------|-------------------------|
| **Primary operation** | `set(row)` | `setCell(rowId, col, val)` |
| **Partial updates** | No | Yes (`updateRow`) |
| **Schema versioning** | Yes | No |
| **Type safety** | `tables.posts.set(...)` typed | `tables.table('posts')` untyped |
| **Memory** | Bounded (YKeyValue) | Unbounded (Y.Map) |
| **Concurrent edits** | Last-write-wins (row) | CRDT merge (cell) |
| **Use case** | Structured app data | Spreadsheets, user-defined tables |

---

## Migration Path

### From Current API

Current `table-helper.ts` is closer to **Dynamic Tables** (cell-level Y.Map storage). To migrate:

1. **For structured data**: Switch to `createTables()` with versioned schemas
   - Replace `upsert()` with `set()`
   - Remove `update()` calls (write full rows instead)
   - Add schema versions if needed

2. **For flexible data**: Switch to `createDynamicTables()`
   - Replace `tables.get('name')` with `tables.table('name')`
   - API is similar but explicitly untyped

### Coexistence

Both APIs can coexist in the same app:

```typescript
// Structured data with schemas
const tables = createTables(ydoc, { posts, users });

// User-created dynamic tables
const dynamicTables = createDynamicTables(ydoc);

// Usage
tables.posts.set({ id: '1', title: 'Hello', views: 0 });
dynamicTables.table('user_table_123').setCell('row-1', 'custom_field', 'value');
```

They use different Y.Doc keys (`tables` vs `dynamic_tables`) so they don't conflict.

---

## Open Questions

1. **Naming**: `createTables` / `createDynamicTables` or something else?

2. **Shared utilities**: Should both APIs share `observe()`, `filter()`, `find()` implementations?

3. **Default**: Which should be the "default" import from `epicenter`?

4. **Y.Doc separation**: Should dynamic tables use a different root key to avoid confusion?

---

## TODO

- [ ] Finalize naming decision
- [ ] Implement `createTables()` per versioned-table-kv spec
- [ ] Implement `createDynamicTables()` (refactor from current table-helper)
- [ ] Add migration guide for existing users
- [ ] Update package exports
